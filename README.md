# #Study_JSP

### JSP(Java Server Page)
	HTML을 중심으로 자바와 연동하여 사용하는 웹 언어.
	HTML 코드 안에 JAVA 코드를 작성할 수 있는 언어.

### 서버
	사용자의 요청에 맞는 서비스를 제공해주는 것.

	* 요청(request)  : 클라이언트 → 서버
	* 응답(response) : 서버 → 클라이언트

### 웹 서버(http) - Apache
	사용자의 요청이 정적 데이터인지 동적 데이터인지 판단함.
	정적 데이터일 경우 미리 준비한 HTML 문서를 그대로 응답해주며
	동적 데이터라면 웹 컨테이너에 요청을 보냄.

### 웹 컨테이너(Servlet Container)
	동적 데이터일 경우 JSP, 서블릿으로 연산 및 제어 그리고 DB까지 접근함.
	DB에 접근하는 연산을 복잡한 연산이라고 하며, 이는 JAVA로 처리함.
	동적 데이터가 정제된 데이터(정적 데이터)로 완성되면 이를 웹 서버를 통해 응답함.


### WAS(Web Application Server) - Tomcat
	동적 데이터를 처리할 서블릿을 메모리에 할당하며, web.xml을 참조한 뒤 알맞은 서블릿에 대한 Thread를 생성.
	서블릿 요청과 응답 객체 생성 후 서블릿에 전달하면, 연산 종료 후 메모리에서 해제시킴.


### 서블릿
	JAVA 코드 안에 HTML 코드를 작성할 수 있는 JAVA 프로그램.
	Thread에 의해 서블릿에 있는 service() 메소드가 호출됨.
	전송 방식에 따라 doGet() 혹은 doPost() 등의 메소드가 호출됨.

### GET 방식과 POST 방식

	* GET
	주로 짧고 보안 필요 없는 데이터를 주고 받을 떄 사용.
	주소에 데이터를 추가하여 전달하는 방식.
	보통 쿼리 문자열(query string)에 포함되어 전송되므로, 길이에 제한이 있고 주소에 데이터가 보이므로 보안상 취약점이 존재함.
	중요한 데이터 혹은 길이가 긴 데이터는 아래의 post 방식을 사용하여 요청하는 것이 좋음.
	하지만 get 방식이 post 방식보다 상대적으로 빠른 전송방식임.
	단순 페이지 이동.
---
	* POST
	데이터를 별도로 첨부(HEADER에 첨부)하여 전달하는 방식.
	브라우저 히스토리에도 남지 않고 데이터는 쿼리 문자열과는 별도로 전송됨.
	따라서 데이터의 길이에 제한도 없으며, get방식보다 보안성이 높음.
	하지만 get방식보다 상대적으로 느림.
	DB에 접근.



### forward 방식과 redirect 방식.
	* forward
		요청한 경로가 그대로 남아있기 때문에 응답 페이지를 보더라도	요청한 경로가 표시됨.
		.jsp로 이동해야 할 때에는 확장자가 표시되지 않게 하기 위해서 forward 방식을 사용함.	
		단순 페이지 이동 혹은 응답 페이지에 필요한 데이터를 전달하고 할 때 사용하는 방식임.

	* redirect
		요청한 경로는 초기화되기 때문에 응답한 경로가 표시됨.
		다른 서블릿으로 요청해야 할 때에는 이전 요청 경로가 표시되면 안되기 떄문에 redirect 방식을 사용.
		DB 연산 등 복잡한 연산 수행 후 응답 페이지로 이동해야 할 때, 응답 페이지로 이동시켜주는 다른 서블릿으로 요청할 경우 사용하는 방식임.

	ex) 결제 완료 후 redirect로 페이지 이동하는 서블릿에 요청, 페이지 이동하는 서블릿은 forward로 처리.

## 디자인 패턴

###  JSP

	a.jsp --> b.jsp --> c.jsp

	* 각 페이지마다 필요 시 자바 코드가 작성되며, DB와 연결하는 코드도 jsp파일 안에서 모두 작성된다.
	* 분리되어 있지 않기 때문에 규모가 작은 프로젝트에 어울리는 방식이다.
	* 코드가 확장될 수록 가독성이 떨어지고 분업과 유지보수가 좋지 않다.

### MVC
---
#### * Model1 방식
	a.jsp --> b.jsp --> c.jsp
		   ↓
		DAO.java

	* b.jsp에서 DAO를 호출함으로써 자바코드가 섞이게 된다.
	* 선언은 JAVA 페이지에 구현이 되어 있기 때문에 jsp 내의 JAVA 코드 양이 줄어들게 된다.
	* 결국 사용은 jsp 페이지에서 하기 때문에 Controller와 View가 섞이게 된다.
		- Controller에서 DAO의 메소드를 사용하고 어디 페이지로 이동할 지가 같은 곳에서 이뤄짐.
	* 페이지가 확장될 수록 유지보수가 좋지 않다. 하지만 설계하기에는 용이하다.

#### * Model2 방식
	a.jsp	-->	web.xml	-->	Front-Controller.java	------------>	c.jsp
						↓
					Controller.java
					    ↓
					DAO.java
					 ↓
					DB

	* a.jsp에서 다음 페이지를 이동하기 전 필요한 비지니스 로직을 완벽하게 분리하여 관리한다.

	* 사용자가 정의한 확장자(.me, .bo, ...)를 페이지 이동 주소(URL)에 작성하게 되면 web.xml에 가서 경로를 찾는다.

	* web.xml에 파일 경로를 하나씩 모두 만들게 되면	코드가 길어지기 때문에 *.me와 같이 그룹화시킨 확장자로 요청을 하나의 경로로 보내주도록 설정해 놓는다.

	* 이 경로를 알맞는 Front-Controller.java 경로로 설정해 놓는다.

	* Front-Controller에서는 들어온 요청에서 .me앞의 요청 명으로 어떤 로직을 수행할 지를 판단하도록 분기처리를 한다.

	* 비즈니스 로직을 Front-Controller에서 작업하게 되면 마찬가지로 코드가 길어지고 유지보수 및 재사용이 어렵기 때문에 요청별 Controller를 만들어서 req와 resp를 받을 메소드를 선언하여 구현한다. 

	* 따라서 Controller안에 선언된 메소드는 모든 Controller에 구현해야 하기 때문에 인터페이스를 선언하여 추상메소드 형태로 선언해 놓고 각 Controller에 지정하여 구현하도록 한다.

	* 메소드 내부에서의 DB연산 작업들은 모두 DAO로 분리하여 사용한다.

	* 내부 작업이 모두 완료되면 페이지를 이동할 것인지, 어떤 방식으로 할 것인지, 그리고 어디로 이동할 것인지를 결정해서 리턴해야 한다. 이에 관련된 필드를 클래스로 만들어 놓은 후 Controller안에 선언한 메소드의 리턴타입으로 지정하여 Front-Controller에 리턴해준다.

	* Front-Controller에서는 해당 Controller 메소드의 리턴 값에 담긴 결과에 맞게 처리한 후 View로 이동하게 된다.


### DBCP(Database Connection Pool)
	사용자 요청이 있을 때마다 DB연결을 한다면, 많은 요청이 있을 때 연결 속도가 저하될 수 있음.
	따라서 미리 Connection 객체를 만들어 두고, 필요 시 저장된 공간에서 활성화하여 가져다 쓴 후 
	반환하는 기법.

### JNDI(Java Naming and Directory Interface)
	디렉토리 서비스에서 제공하는 자바 API이며, 데이터 및 객체를 발견한 뒤 참조함.
	외부에 있는 객체를 가져오기 위한 기술.


### MyBatis Framework
	소스코드 안에 SQL문을 작성하면 코드가 길어지고 섞여 있어서 유지보수 및 분업이 어려움.
	MyBatis는 기존 JDBC 방식과는 달리 SQL문을 XML파일에 작성함으로써 코드가 줄어들고,
	SQL문 수정이 편함. 
